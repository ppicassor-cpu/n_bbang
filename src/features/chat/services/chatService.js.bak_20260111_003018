import { db, auth } from "./././firebaseConfig";
import { 
  collection, 
  doc, 
  setDoc, 
  getDoc, 
  addDoc, 
  updateDoc, 
  deleteDoc,
  arrayUnion, 
  arrayRemove, 
  serverTimestamp, 
  query, 
  orderBy, 
  onSnapshot, 
  where,
  writeBatch
} from "firebase/firestore";

// ✅ 1. 채팅방 생성 또는 입장 (재입장 시 시간 갱신 로직 정밀화)
export const ensureRoom = async (roomId, roomName, type, ownerId) => {
  if (!auth.currentUser) return;
  const userId = auth.currentUser.uid;
  const roomRef = doc(db, "chatRooms", roomId);
  const roomSnap = await getDoc(roomRef);

  if (!roomSnap.exists()) {
    const participantList = [userId];
    if (ownerId && ownerId !== userId) {
      participantList.push(ownerId);
    }
    await setDoc(roomRef, {
      id: roomId,
      title: roomName,
      type: type || "group",
      ownerId: ownerId || userId, // ✅ 방장 식별용 (없으면 만든 사람)
      closed: false,              // ✅ 종료 플래그
      participants: participantList,
      [`joinedAt_${userId}`]: serverTimestamp(),
      ...(ownerId && ownerId !== userId ? { [`joinedAt_${ownerId}`]: serverTimestamp() } : {}),
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp(),
      lastMessage: "채팅방이 개설되었습니다.",
    });
  } else {
    const data = roomSnap.data();
    const currentParticipants = data.participants || [];
    const updateData = {};

    // ✅ ownerId가 비어있고 ownerId가 전달되면 보정 (기존 방 호환)
    if (ownerId && !data.ownerId) {
      updateData.ownerId = ownerId;
    }

    // ✅ 방이 종료된 경우에도 "입장/목록 표시"는 유지하되, 메시지 전송은 sendMessage에서 차단
    if (!currentParticipants.includes(userId)) {
      updateData.participants = arrayUnion(userId);
      updateData[`joinedAt_${userId}`] = serverTimestamp();
    }

    if (ownerId === userId && !currentParticipants.includes(userId)) {
      updateData[`joinedAt_${userId}`] = serverTimestamp();
    }

    if (ownerId && ownerId !== userId && !currentParticipants.includes(ownerId)) {
      updateData.participants = arrayUnion(ownerId);
    }

    if (Object.keys(updateData).length > 0) {
      await updateDoc(roomRef, updateData);
    }
  }
};

// ✅ 2. 메시지 전송 (채팅 종료 시 서버단 차단)
export const sendMessage = async (roomId, text) => {
  if (!auth.currentUser || !text.trim()) return;
  const user = auth.currentUser;

  const roomRef = doc(db, "chatRooms", roomId);
  const roomSnap = await getDoc(roomRef);
  if (roomSnap.exists()) {
    const roomData = roomSnap.data();
    if (roomData?.closed) {
      // ✅ 종료된 방: 아무도 메시지 전송 불가
      throw new Error("CHAT_ROOM_CLOSED");
    }
  }

  await addDoc(collection(db, "chatRooms", roomId, "messages"), {
    text: text,
    senderId: user.uid,
    senderEmail: user.email,
    senderNickname: user.displayName || user.email.split("@")[0],
    createdAt: serverTimestamp(),
    readBy: [user.uid],
  });

  await updateDoc(roomRef, {
    lastMessage: text,
    updatedAt: serverTimestamp(),
  });
};

// ✅ 3. 메시지 실시간 구독 (중복 구독 해제 및 로직 강화)
export const subscribeMessages = (roomId, callback) => {
  if (!auth.currentUser) return () => {};
  const userId = auth.currentUser.uid;
  const roomRef = doc(db, "chatRooms", roomId);
  const messagesRef = collection(db, "chatRooms", roomId, "messages");
  const q = query(messagesRef, orderBy("createdAt", "asc"));

  let msgUnsubscribe = null;

  const roomUnsubscribe = onSnapshot(roomRef, (roomSnap) => {
    if (!roomSnap.exists()) return;
    
    const roomData = roomSnap.data();
    const joinedAt = roomData[`joinedAt_${userId}`];
    
    if (!joinedAt) return;
    const joinedDate = joinedAt.toDate();

    if (msgUnsubscribe) msgUnsubscribe();

    msgUnsubscribe = onSnapshot(q, (snapshot) => {
      const allMessages = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data(),
        createdAt: doc.data().createdAt?.toDate() || new Date()
      }));

      const filterTime = joinedDate.getTime() - 1000; // 오차 범위를 1초로 확대
      const filtered = allMessages.filter(m => m.createdAt.getTime() >= filterTime);
      
      callback(filtered);
    });
  });

  return () => {
    roomUnsubscribe();
    if (msgUnsubscribe) msgUnsubscribe();
  };
};

// ✅ 4. 내 채팅방 목록 구독
export const subscribeMyRooms = (callback) => {
  if (!auth.currentUser) return () => {};
  const q = query(
    collection(db, "chatRooms"),
    where("participants", "array-contains", auth.currentUser.uid),
    orderBy("updatedAt", "desc")
  );
  return onSnapshot(q, (snapshot) => {
    const rooms = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
      updatedAt: doc.data().updatedAt?.toDate() || new Date()
    }));
    callback(rooms);
  });
};

// ✅ 5. 메시지 읽음 처리
export const markAsRead = async (roomId, messageIds) => {
  if (!auth.currentUser || !messageIds || messageIds.length === 0) return;
  const batch = writeBatch(db);
  const userId = auth.currentUser.uid;

  messageIds.forEach((msgId) => {
    const msgRef = doc(db, "chatRooms", roomId, "messages", msgId);
    batch.update(msgRef, { readBy: arrayUnion(userId) });
  });
  await batch.commit();
};

// ✅ 6. 채팅방 나가기 (일반 유저)
export const leaveRoom = async (roomId) => {
  if (!auth.currentUser) return;
  const user = auth.currentUser;
  const nickname = user.displayName || user.email.split("@")[0];
  const roomRef = doc(db, "chatRooms", roomId);
  
  await addDoc(collection(db, "chatRooms", roomId, "messages"), {
    text: `${nickname}님이 채팅방을 떠났습니다.`,
    senderId: "system",
    senderNickname: "시스템",
    createdAt: serverTimestamp(),
    readBy: [user.uid],
  });

  await updateDoc(roomRef, {
    participants: arrayRemove(user.uid),
    lastMessage: `${nickname}님이 퇴장하셨습니다.`,
    updatedAt: serverTimestamp()
  });
};

// ✅ 7. 방장 나가기 = 게시글 삭제 + 채팅 종료(잠금) + 종료 시스템메세지
export const closeRoomAsOwner = async (roomId) => {
  if (!auth.currentUser) return;

  const user = auth.currentUser;
  const nickname = user.displayName || user.email.split("@")[0];

  const roomRef = doc(db, "chatRooms", roomId);

  // ✅ 1) 종료 시스템 메세지 먼저 남기기
  await addDoc(collection(db, "chatRooms", roomId, "messages"), {
    text: `채팅방/N빵참여가 종료되었습니다.`,
    senderId: "system",
    senderNickname: "시스템",
    createdAt: serverTimestamp(),
    readBy: [user.uid],
  });

  // ✅ 2) 방 잠금 + 게시글 삭제
  // roomId가 post_XXXX 형식이면 posts/XXXX 삭제
  let postId = null;
  if (typeof roomId === "string" && roomId.startsWith("post_")) {
    postId = roomId.replace(/^post_/, "");
  }

  const batch = writeBatch(db);

  // 방 종료 플래그
  batch.update(roomRef, {
    closed: true,
    closedAt: serverTimestamp(),
    closedBy: user.uid,
    lastMessage: "채팅방/N빵참여가 종료되었습니다.",
    updatedAt: serverTimestamp(),
  });

  // 게시글 삭제 (있을 때만)
  if (postId) {
    const postRef = doc(db, "posts", postId);
    batch.delete(postRef);
  }

  await batch.commit();

  // ✅ 3) 마지막으로 방장도 참가자에서 제거(선택: 기존 로직과 동일하게 "나가기" 처리 느낌 유지)
  // - 종료된 방이라 남은 유저도 대화 불가이므로, 방장이 목록에서 빠지는 게 자연스럽습니다.
  try {
    await updateDoc(roomRef, {
      participants: arrayRemove(user.uid),
    });
  } catch (e) {
    // roomRef가 삭제되거나 권한 문제 등이라도 종료는 이미 처리됨
  }

  // 참고: 남은 유저는 room.closed=true 상태로 sendMessage가 서버에서 막힘
};