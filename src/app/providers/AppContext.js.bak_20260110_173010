import React, { createContext, useState, useContext, useEffect } from "react";
import * as Location from "expo-location";

const AppContext = createContext();

// 거리 계산 함수 (Haversine formula)
function getDistanceFromLatLonInKm(lat1, lon1, lat2, lon2) {
  if (lat1 == null || lon1 == null || lat2 == null || lon2 == null) return 9999;

  const R = 6371;
  const dLat = deg2rad(lat2 - lat1);
  const dLon = deg2rad(lon2 - lon1);
  const a =
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(deg2rad(lat1)) *
      Math.cos(deg2rad(lat2)) *
      Math.sin(dLon / 2) *
      Math.sin(dLon / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  const d = R * c;
  return d;
}

function deg2rad(deg) {
  return deg * (Math.PI / 180);
}

// "동/읍/면/리/가" 추출
function pickDongFromText(raw) {
  if (!raw) return null;
  const str = String(raw).trim();
  if (!str) return null;

  const cleaned = str.replace(/[()\[\]{}【】]/g, " ");
  const parts = cleaned.split(/[\s,]+/).filter(Boolean);

  for (const p of parts) {
    let compact = p.trim();
    if (!compact) continue;

    // 끝에 붙는 점/하이픈 등 제거
    compact = compact.replace(/[^가-힣0-9]/g, "");
    if (!compact) continue;

    // 도로명(로/길/대로) 제외
    if (/(로|길|대로)$/.test(compact)) continue;

    if (/^[가-힣0-9]+(동|읍|면|리|가)$/.test(compact)) {
      return compact;
    }
  }

  // 문장 중간에 섞여있는 케이스 1회 추가 탐색
  const mid = cleaned.replace(/[^가-힣0-9\s]/g, " ");
  const m = mid.match(/([가-힣0-9]+(동|읍|면|리|가))/);
  return m ? m[1] : null;
}

// 1) Expo reverseGeocodeAsync 우선
async function getDongFromExpoReverseGeocode(coords) {
  try {
    const addresses = await Location.reverseGeocodeAsync(coords);
    if (!addresses || addresses.length === 0) return null;

    for (const addr of addresses) {
      const candidates = [
        addr.district,
        addr.subregion,
        addr.city,
        addr.street,
        addr.name,
        addr.region,
      ].filter(Boolean);

      for (const c of candidates) {
        const dong = pickDongFromText(c);
        if (dong) return dong;
      }
    }

    // 전체 문자열로 1회 더
    const first = addresses[0] || {};
    const fallbackText = [
      first.district,
      first.subregion,
      first.city,
      first.street,
      first.name,
      first.region,
    ]
      .filter(Boolean)
      .join(" ");
    return pickDongFromText(fallbackText);
  } catch {
    return null;
  }
}

// 2) (선택) 카카오 로컬 API (있으면 더 정확하게 행정동)
async function getDongFromKakao(coords) {
  const key = process.env.EXPO_PUBLIC_KAKAO_REST_API_KEY;
  if (!key) return null;

  try {
    const x = coords.longitude;
    const y = coords.latitude;
    const url = `https://dapi.kakao.com/v2/local/geo/coord2regioncode.json?x=${encodeURIComponent(
      x
    )}&y=${encodeURIComponent(y)}`;

    const res = await fetch(url, {
      headers: { Authorization: `KakaoAK ${key}` },
    });
    if (!res.ok) return null;

    const json = await res.json();
    const docs = json?.documents || [];
    const h = docs.find((d) => d?.region_type === "H" && d?.region_3depth_name);
    const b = docs.find((d) => d?.region_type === "B" && d?.region_3depth_name);

    return h?.region_3depth_name || b?.region_3depth_name || null;
  } catch {
    return null;
  }
}

// 3) (대체) OSM Nominatim (키 없이도 시도 가능)
async function getDongFromOSM(coords) {
  try {
    const url = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${encodeURIComponent(
      coords.latitude
    )}&lon=${encodeURIComponent(coords.longitude)}&zoom=18&accept-language=ko`;

    const res = await fetch(url, {
      headers: { "Accept-Language": "ko" },
    });
    if (!res.ok) return null;

    const json = await res.json();
    const addr = json?.address || {};

    const candidates = [
      addr.neighbourhood,
      addr.suburb,
      addr.quarter,
      addr.city_district,
      addr.town,
      addr.village,
      addr.hamlet,
    ].filter(Boolean);

    for (const c of candidates) {
      const dong = pickDongFromText(c);
      if (dong) return dong;
    }

    return pickDongFromText(json?.display_name);
  } catch {
    return null;
  }
}

async function resolveAdminDong(coords) {
  const fromExpo = await getDongFromExpoReverseGeocode(coords);
  if (fromExpo) return fromExpo;

  const fromKakao = await getDongFromKakao(coords);
  if (fromKakao) return fromKakao;

  const fromOSM = await getDongFromOSM(coords);
  if (fromOSM) return fromOSM;

  return null;
}

export const AppProvider = ({ children }) => {
  const [currentLocation, setCurrentLocation] = useState("위치 찾는 중...");
  const [myCoords, setMyCoords] = useState(null);
  const [myPoints, setMyPoints] = useState(50000);
  const [posts, setPosts] = useState([
    {
      id: "1",
      ownerId: "other_user",
      category: "대형마트",
      title: "코스트코 소고기 소분해요",
      location: "내동",
      coords: { latitude: 35.2320, longitude: 128.8710 },
      pickup_point: "현대아파트 정문",
      price: 30000,
      pricePerPerson: 15000,
      tip: 1000,
      currentParticipants: 2,
      maxParticipants: 4,
      images: [],
      status: "모집중",
      content: "소고기 반 나누실 분!",
    },
  ]);

  useEffect(() => {
    (async () => {
      let { status } = await Location.requestForegroundPermissionsAsync();
      if (status !== "granted") {
        setCurrentLocation("위치 권한 없음");
        return;
      }

      let location = await Location.getCurrentPositionAsync({});
      setMyCoords(location.coords);

      const dong = await resolveAdminDong(location.coords);
      if (dong) {
        setCurrentLocation(dong);
        return;
      }

      // 최후 fallback (동/읍/면 못 얻었을 때)
      const addresses = await Location.reverseGeocodeAsync(location.coords).catch(() => null);
      const first = addresses?.[0];
      setCurrentLocation(
        first?.district || first?.subregion || first?.city || first?.region || "내 위치"
      );
    })();
  }, []);

  const addPost = (newPost) => {
    setPosts((prevPosts) => [newPost, ...prevPosts]);
  };

  return (
    <AppContext.Provider
      value={{
        currentLocation,
        myCoords,
        setCurrentLocation,
        myPoints,
        posts,
        addPost,
        getDistanceFromLatLonInKm,
      }}
    >
      {children}
    </AppContext.Provider>
  );
};

export const useAppContext = () => useContext(AppContext);